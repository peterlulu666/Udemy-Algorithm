{"./":{"url":"./","title":"Introduction","keywords":"","body":"Udemy Algorithm in C Udemy Algorithm in C "},"concept.html":{"url":"concept.html","title":"C and C++ concept","keywords":"","body":"C and C++ concept "},"Structure.html":{"url":"Structure.html","title":"Strudcture","keywords":"","body":"Strudcture Create rectangle Create complex number Create student Play cards Create rectangle struct Rectangle{ int length; int breadth; } int main(){ // initialize variable struct Rectangle r; // initialize and declare variable struct Rectangle r = {10, 5}; r.length = 15; r.breadth = 10; printf(\"Area of Rectangle is %d\", r.length * r.breadth); } Create complex number struct Complex{ int realNumber; int imgNumber; } Create student struct Student{ int roll; char name[28]; char department[10]; char address[90]; } // We would access the date struct Student s; s.roll = 10; r.name = \"Bob\"; Play cards struct Card{ int face; int shape; int color; } int main{ struct Card c; c.face = 1; c.shape = 0; c.color = 0; } int main(){ struct Card deck[52] = {{1, 0, 0}, {2, 0, 0}... {1, 1, 0}, {2, 1, 0}... ... } printf(\"%d\", deck[0].face); printf(\"%d\", deck[0].shape); } "},"Pointer.html":{"url":"Pointer.html","title":"Pointer","keywords":"","body":"Pointer Pointer Accessing heap using poiner Refernece Pointer to structure Dynamic allocation Pointer Pointer is used for storing address of data. Pointer will not store the data itself. [info] The usage of the pointer Accessing heap. Accessing recourse. Parameter passing. int main{ // declare and initialize data variable int a = 10; // declare address variable int* p; // initialize address variable and p stores the address of a p = &a; // accessing data using data referencing printf(\"%d\", *p) } Accessing heap using poiner int main{ int* p; p = (int*)malloc(5 * sizeof(int)); } In C++ p = new int[5]; Refernece In C++ int main{ // declare and initialize variable int a = 10; // declare and initialize refernece int &b = a; // a is 10 cout Pointer to structure struct Rectangle{ int length; int breadth; } int main{ struct Rectangle a = {10, 5}; // declare and initialize the pointer struct Rectangle *p = &a; // accessing the struct member using normal variable a.length = 15; // accessing the struct member using poiner variable (*p).length = 20; // accessing the struct member using poiner variable p -> length = 20; } Dynamic allocation struct Rectangle{ int length; int breadth; } int main{ struct Rectangle *p; //create variable in heap by using malloc function p =(struct Rectangle*) malloc(sizeof(struct Rectangle)); // assign variable length p -> length = 10; // assign variable breadth p -> breadth = 5; } "},"Function.html":{"url":"Function.html","title":"Function","keywords":"","body":"Function Function Add function Function parameter Using array as parameter Function Monolithic programming int main{ ... ... ... } [info] Monolithic programming Write all the code in main. This is difficult to maintain. Procedural programming funA{ ... ... ... } funB{ ... ... ... } funC{ ... ... ... } int main(){ funA(); funB(); funC(); } [info] Procedural programming Write multuple function and integrate them together in the main. Increase productivity and reusability. Add function #include //a and b are parameter int add(int a, int b){ // declare variable int c; // assign variable c = a + b; return (c); } int main(){ //declare and assign variable int x = 10; //declare and assign variable int y = 5; //declare variable int z; // call the function // x and y are argument z = add(x, y); printf(\"%d\", z); } Function parameter Using value as parameter void swap(int x, int y){ int temp; temp = x; x = y; y = temp; } int main(){ int a = 10; int b = 20; swap(a, b); printf(\"%d %d\", a,b); } [info] Using value as parameter We copy the value a to value x and copy the value b to value y. We swap the value x and value y. x will be 20 and y will be 10. value a and value 'b' will remain the same. These value will not be swapped. a is 10 and b is 20. When you do not want to modify the value itself you would use value as parameter. Using pointer as parameter #include void swap(int* x, int* y){ int temp; temp = *x; *x = *y; *y = temp; } int main(){ int a = 10; int b = 20; swap(&a, &b); printf(\"%d %d\", a,b); } [info] Using pointer as parameter When we call the swap function, it will take address variable &a and &b as argument. When we define the function, the parameter will be int* x and int* y. We also need to modify the x to *x and modify y to *y. We copy the value of a to x and copy the value of b to y. We swap the value x and value y. The x is pointing to a and y is pointing to b. The value a will be 20 and value b will be 10. Using reference as parameter This is the feature of C++ #include void swap(int &x, int &y){ int temp; temp = x; x = y; y = temp; } int main(){ int a = 10; int b = 20; swap(a, b); printf(\"%d %d\", a,b); } [info] Using reference as parameter When we define the function, the parameter will be int &x and int &y. Using array as parameter #include void fun(int arr[], int n) { for (int i = 0; i [info] Using array as parameter We would use empty bracket. arr is the pointer to array. arr[] is the address. We would use int *arr. The pointer arr will point to any array. #include void fun(int arr[], int n) { arr[0] = 25; for (int i = 0; i [info] Using array as parameter We modified the element in index 0. #include int [] fun(int n) { int* ptr; ptr = (int*)malloc(n * sizeof(int)); return(ptr); } int main() { int* arr; arr = fun(5); } [info] How function can return array Using structure as parameter #include struct Rectangle { int length; int breadth; }; int area(struct Rectangle n) { n.length++; return n.length * n.breadth; } int main() { struct Rectangle r = {5, 10}; printf(\"%d\", area(r)); } Call by reference is the feature in C++. We would use &n when we define the function. #include struct Rectangle { int length; int breadth; }; int area(struct Rectangle &n) { // modify length value n.length++; return n.length * n.breadth; } int main() { struct Rectangle r = {5, 10}; printf(\"%d\", area(r)); } We would modify using changeLength function. #include struct Rectangle { int length; int breadth; }; void changeLength(struct Rectangle *p, int length) { p -> length = length; } int main() { struct Rectangle r = {5, 10}; changeLength(&r, 20); printf(\"%d\", r); } Structure and function #include struct Rectangle { int length; int breadth; }; // initialize the value void initializeSize(struct Rectangle *p, int length, int breadth) { // using the pointer to setup length and breadth p->length = length; p->breadth = breadth; } // using value as parameter // this would not directly access the structure // this would copy the value of structure int area(struct Rectangle rectangle) { return rectangle.length * rectangle.breadth; } // using pointer as parameter // this would directly access the structure // this would modify the value of length void changeLength(struct Rectangle *p, int length) { p->length = length; } int main() { struct Rectangle r; initializeSize(&r, 5, 10); int a = area(r); printf(\"length is %d\\n\", r); printf(\"area is %d\\n\", a); changeLength(&r, 20); int b = area(r); printf(\"length is %d\\n\", r); printf(\"area is %d\\n\", b); } Converting C to C++ #include // we would use class class Rectangle { private:int length; private:int breadth; // initialize the value //void initializeSize(struct Rectangle *p, int length, int breadth) { // // using the pointer to setup length and breadth // p->length = length; // p->breadth = breadth; // //} // we would use constructor to initialize the value public:Rectangle(int length, int breadth) { this->length = length; this->breadth = breadth; } public:int area() { // return rectangle.length * rectangle.breadth; return length * breadth; } // we would use this parameter public:void changeLength(int length) { this->length = length; } }; int main() { //struct Rectangle r; //initializeSize(&r, 5, 10); Rectangle r (5, 10); //int a = area(r); int a = r.area(); // printf(\"length is %d\\n\", r); printf(\"area is %d\\n\", a); // changeLength(&r, 20); r.changeLength(20); // int b = area(r); int b = r.area(); // printf(\"length is %d\\n\", r); printf(\"area is %d\\n\", b); } "}}